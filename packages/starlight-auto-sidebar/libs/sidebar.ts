import type { StarlightRouteData } from '@astrojs/starlight/route-data'
import type { HookParameters, StarlightUserConfig } from '@astrojs/starlight/types'

import { type Definition, type Definitions, getDefinitionsForDirectory } from './definitions'
import { stripLeadingSlash, stripTrailingSlash } from './path'
import { getDefaultLang, getEntryOrder } from './starlight'
import type { StarlightAutoSidebarContext } from './vite'

const base = stripLeadingSlash(import.meta.env.BASE_URL)

export async function getDefinitionsFromSidebarConfig(
  contentDir: URL,
  config: NonNullable<StarlightUserConfig['sidebar']>,
): Promise<Definitions> {
  let definitions: Definitions = {}

  for (const itemConfig of config) {
    if (isSidebarAutogeneratedGroupConfig(itemConfig)) {
      const dir = new URL(itemConfig.autogenerate.directory, contentDir)
      const dirDefinitions = await getDefinitionsForDirectory(dir)
      definitions[dir.pathname] = dirDefinitions
    } else if (isSidebarManualGroupConfig(itemConfig)) {
      definitions = { ...definitions, ...(await getDefinitionsFromSidebarConfig(contentDir, itemConfig.items)) }
    }
  }

  return definitions
}

export async function updateSidebarItems(
  items: SidebarItem[],
  context: StarlightAutoSidebarContext,
): Promise<SidebarItem[]> {
  const sidebar: SidebarItem[] = []

  for (const [index, itemConfig] of context.sidebar.entries()) {
    const item = items[index]
    if (!item) {
      continue
    } else if (isSidebarSlugItemConfig(itemConfig) || isSidebarLinkItemConfig(itemConfig)) {
      sidebar.push(item)
    } else if (isSidebarManualGroupConfig(itemConfig) && isSidebarGroup(item)) {
      sidebar.push({
        ...item,
        entries: await updateSidebarItems(item.entries, { ...context, sidebar: itemConfig.items }),
      })
    } else if (isSidebarAutogeneratedGroupConfig(itemConfig) && isSidebarGroup(item)) {
      sidebar.push({
        ...item,
        entries: await updateAutogeneratedGroup(itemConfig, item.entries, context),
      })
    }
  }

  return sidebar
}

async function updateAutogeneratedGroup(
  config: SidebarAutogeneratedGroupConfig,
  items: SidebarItem[],
  context: StarlightAutoSidebarContext,
  segments: string[] = [],
): Promise<SidebarItem[]> {
  if (segments.length === 0) {
    const dir = new URL(config.autogenerate.directory, context.contentDir)
    const definition = context.definitions[dir.pathname]?.['']
    items = await sortAutogeneratedGroupItems(definition, items, config.autogenerate.directory, context)
  }

  return Promise.all(
    items.map(async (item) => {
      const itemSegments = [...segments, item.label]
      const itemPath = itemSegments.join('/')
      const dir = new URL(config.autogenerate.directory, context.contentDir)
      const definition = context.definitions[dir.pathname]?.[itemPath]

      if (item.type === 'group') {
        const label = definition?.label ?? item.label
        const entries = await sortAutogeneratedGroupItems(definition, item.entries, itemPath, context)

        return {
          ...item,
          label,
          entries: await updateAutogeneratedGroup(config, entries, context, itemSegments),
        }
      }

      return {
        ...item,
        // TODO(HiDeoo)
        // label: `${item.label} (modified)`,
      }
    }),
  )
}

async function sortAutogeneratedGroupItems(
  definition: Definition | undefined,
  items: SidebarItem[],
  path: string,
  context: StarlightAutoSidebarContext,
): Promise<SidebarItem[]> {
  if (!definition) return items

  switch (definition.sort) {
    case 'reverse-slug': {
      const orders = await getItemsOrder(items, path)
      const collator = new Intl.Collator(getDefaultLang(context))

      orders.sort(({ order: aOrder, path: aPath }, { order: bOrder, path: bPath }) => {
        if (aOrder !== bOrder) return aOrder < bOrder ? -1 : 1
        return collator.compare(aPath, bPath) * -1
      })

      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      return orders.map(({ index }) => items[index]!)
    }
    default: {
      return items
    }
  }
}

function getItemsOrder(items: SidebarItem[], path: string): Promise<{ index: number; order: number; path: string }[]> {
  return Promise.all(
    items.map(async (item, index) => {
      return isSidebarLink(item)
        ? {
            index,
            order: await getEntryOrder(item.href),
            path: stripLeadingSlash(stripTrailingSlash(item.href)).replace(base, ''),
          }
        : {
            index,
            order: Number.MAX_VALUE,
            path: `${path}/${item.label}`,
          }
    }),
  )
}

function isSidebarSlugItemConfig(itemConfig: SidebarItemConfig): itemConfig is SidebarSlugItemConfig {
  return typeof itemConfig === 'string' || 'slug' in itemConfig
}

function isSidebarLinkItemConfig(itemConfig: SidebarItemConfig): itemConfig is SidebarLinkItemConfig {
  return typeof itemConfig === 'object' && 'link' in itemConfig
}

function isSidebarManualGroupConfig(itemConfig: SidebarItemConfig): itemConfig is SidebarManualGroupConfig {
  return typeof itemConfig === 'object' && 'items' in itemConfig
}

function isSidebarAutogeneratedGroupConfig(
  itemConfig: SidebarItemConfig,
): itemConfig is SidebarAutogeneratedGroupConfig {
  return typeof itemConfig === 'object' && 'autogenerate' in itemConfig
}

function isSidebarLink(item: SidebarItem): item is SidebarLink {
  return item.type === 'link'
}

function isSidebarGroup(item: SidebarItem): item is SidebarGroup {
  return item.type === 'group'
}

export type SidebarItemConfig = NonNullable<HookParameters<'config:setup'>['config']['sidebar']>[number]
type SidebarSlugItemConfig = Extract<SidebarItemConfig, string | { slug: string }>
type SidebarLinkItemConfig = Extract<SidebarItemConfig, { link: string }>
type SidebarManualGroupConfig = Extract<SidebarItemConfig, { items: SidebarItemConfig[] }>
type SidebarAutogeneratedGroupConfig = Extract<SidebarItemConfig, { autogenerate: { directory: string } }>

type SidebarItem = StarlightRouteData['sidebar'][number]
type SidebarLink = Extract<SidebarItem, { type: 'link' }>
type SidebarGroup = Extract<SidebarItem, { type: 'group' }>

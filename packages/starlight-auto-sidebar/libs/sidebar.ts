import type { StarlightRouteData } from '@astrojs/starlight/route-data'

import { stripBase } from './astro'
import type { Metadata } from './metadata'
import { stripLeadingAndTrailingSlash } from './path'
import {
  isSidebarAutogeneratedGroupConfig,
  isSidebarLinkItemConfig,
  isSidebarManualGroupConfig,
  isSidebarSlugItemConfig,
  type SidebarAutogeneratedGroupConfig,
} from './sidebarConfig'
import { getDefaultLang, getEntryOrder } from './starlight'
import type { StarlightAutoSidebarContext } from './vite'

export async function updateSidebar(items: StarlightRouteData['sidebar'], context: StarlightAutoSidebarContext) {
  return updateSidebarItems(items, context)
}

async function updateSidebarItems(items: SidebarItem[], context: StarlightAutoSidebarContext): Promise<SidebarItem[]> {
  const sidebar: SidebarItem[] = []

  for (const [index, itemConfig] of context.sidebar.entries()) {
    const item = items[index]

    if (!item) {
      continue
    } else if (isSidebarSlugItemConfig(itemConfig) || isSidebarLinkItemConfig(itemConfig)) {
      sidebar.push(item)
    } else if (isSidebarManualGroupConfig(itemConfig) && isSidebarGroup(item)) {
      sidebar.push({
        ...item,
        entries: await updateSidebarItems(item.entries, { ...context, sidebar: itemConfig.items }),
      })
    } else if (isSidebarAutogeneratedGroupConfig(itemConfig) && isSidebarGroup(item)) {
      sidebar.push({
        ...item,
        entries: await updateAutogeneratedGroup(item.entries, {
          ...context,
          config: itemConfig,
          segments: [],
        }),
      })
    }
  }

  return sidebar
}

async function updateAutogeneratedGroup(items: SidebarItem[], context: SidebarUpdateContext): Promise<SidebarItem[]> {
  if (isAutogeneratedGroupRoot(context)) {
    items = await sortAutogeneratedGroupItems(getAutogeneratedGroupDirMetadata(context), items, context)
  }

  return Promise.all(
    items.map(async (item) => {
      const itemContext = createChildUpdateContext(item, context)
      const metadata = getAutogeneratedGroupDirMetadata(itemContext)

      if (item.type === 'group') {
        const label = metadata?.label ?? item.label
        const entries = await sortAutogeneratedGroupItems(metadata, item.entries, itemContext)

        return {
          ...item,
          label,
          entries: await updateAutogeneratedGroup(entries, itemContext),
        }
      }

      return {
        ...item,
        // TODO(HiDeoo)
        // label: `${item.label} (modified)`,
      }
    }),
  )
}

async function sortAutogeneratedGroupItems(
  metadata: Metadata | undefined,
  items: SidebarItem[],
  context: SidebarUpdateContext,
): Promise<SidebarItem[]> {
  const orders = await getAutogeneratedGroupItemsOrder(items, context)
  const collator = new Intl.Collator(getDefaultLang(context))

  orders.sort(({ order: aOrder, path: aPath }, { order: bOrder, path: bPath }) => {
    if (aOrder !== bOrder) return aOrder < bOrder ? -1 : 1
    return collator.compare(aPath, bPath) * (metadata?.sort === 'reverse-slug' ? -1 : 1)
  })

  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
  return orders.map(({ index }) => items[index]!)
}

function getAutogeneratedGroupItemsOrder(
  items: SidebarItem[],
  context: SidebarUpdateContext,
): Promise<AutogeneratedGroupItemsOrder> {
  return Promise.all(
    items.map(async (item, index) => {
      if (isSidebarLink(item)) {
        return {
          index,
          order: await getEntryOrder(item.href),
          path: stripBase(stripLeadingAndTrailingSlash(item.href)),
        }
      }

      const metadata = getAutogeneratedGroupDirMetadata(createChildUpdateContext(item, context))

      return {
        index,
        order: metadata?.order ?? Number.MAX_VALUE,
        path: getAutoGeneratedGroupPath(item, context),
      }
    }),
  )
}

function getAutogeneratedGroupDirMetadata({ config, contentDir, metadata, segments }: SidebarUpdateContext) {
  return metadata[new URL(config.autogenerate.directory, contentDir).pathname]?.[segments.join('/')]
}

function isSidebarLink(item: SidebarItem): item is SidebarLink {
  return item.type === 'link'
}

function isSidebarGroup(item: SidebarItem): item is SidebarGroup {
  return item.type === 'group'
}

function getAutoGeneratedGroupPath(group: SidebarGroup, context: SidebarUpdateContext) {
  const trail = isAutogeneratedGroupRoot(context)
    ? context.config.autogenerate.directory
    : `${context.config.autogenerate.directory}/${context.segments.join('/')}`

  return `${trail}/${group.label}`
}

function isAutogeneratedGroupRoot(context: SidebarUpdateContext) {
  return context.segments.length === 0
}

function createChildUpdateContext(child: SidebarItem, context: SidebarUpdateContext) {
  return { ...context, segments: [...context.segments, child.label] }
}

type SidebarItem = StarlightRouteData['sidebar'][number]
type SidebarLink = Extract<SidebarItem, { type: 'link' }>
type SidebarGroup = Extract<SidebarItem, { type: 'group' }>

interface SidebarUpdateContext extends StarlightAutoSidebarContext {
  config: SidebarAutogeneratedGroupConfig
  segments: string[]
}

type AutogeneratedGroupItemsOrder = {
  index: number
  order: number
  path: string
}[]

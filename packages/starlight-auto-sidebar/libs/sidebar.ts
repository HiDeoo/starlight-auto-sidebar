import type { StarlightRouteData } from '@astrojs/starlight/route-data'

import { stripBase } from './astro'
import type { Metadata } from './metadata'
import { stripLeadingAndTrailingSlash } from './path'
import {
  isSidebarAutogeneratedGroupConfig,
  isSidebarLinkItemConfig,
  isSidebarManualGroupConfig,
  isSidebarSlugItemConfig,
  type SidebarAutogeneratedGroupConfig,
} from './sidebarConfig'
import { getDefaultLang, getEntryOrder } from './starlight'
import type { StarlightAutoSidebarContext } from './vite'

const updateContextRootSegmentLabel = Symbol.for('update-context-root-segment-label')

export async function updatePageSidebar(items: StarlightRouteData['sidebar'], context: StarlightAutoSidebarContext) {
  return updateSidebarItems(items, context)
}

async function updateSidebarItems(
  items: SidebarItem[],
  context: StarlightAutoSidebarContext,
): Promise<SidebarUpdateResult> {
  const result: SidebarUpdateResult = { sidebar: [] }

  for (const [index, itemConfig] of context.sidebar.entries()) {
    const item = items[index]

    if (!item) {
      continue
    } else if (isSidebarSlugItemConfig(itemConfig) || isSidebarLinkItemConfig(itemConfig)) {
      result.sidebar.push(item)
    } else if (isSidebarManualGroupConfig(itemConfig) && isSidebarGroup(item)) {
      const {
        sidebar: entries,
        prev,
        next,
      } = await updateSidebarItems(item.entries, { ...context, sidebar: itemConfig.items })
      if (prev) result.prev = prev
      if (next) result.next = next
      result.sidebar.push({ ...item, entries })
    } else if (isSidebarAutogeneratedGroupConfig(itemConfig) && isSidebarGroup(item)) {
      const {
        sidebar: entries,
        prev,
        next,
      } = await updateAutogeneratedGroup(item, {
        ...context,
        config: itemConfig,
        segments: [createUpdateContextRootSegment(items), { group: item, index }],
      })
      if (prev) result.prev = prev
      if (next) result.next = next
      result.sidebar.push({ ...item, entries })
    }
  }

  return result
}

async function updateAutogeneratedGroup(
  group: SidebarGroup,
  context: SidebarUpdateContext,
): Promise<SidebarUpdateResult> {
  if (isAutogeneratedGroupRootSegment(context)) {
    await sortAutogeneratedGroupItems(group, getAutogeneratedGroupDirMetadata(context), context)
  }

  const result: SidebarUpdateResult = { sidebar: [] }

  result.sidebar = await Promise.all(
    group.entries.map(async (item, index) => {
      if (isSidebarGroup(item)) {
        const itemContext = createUpdateContextForGroup(item, index, context)
        const metadata = getAutogeneratedGroupDirMetadata(itemContext)

        const label = metadata?.label ?? item.label
        await sortAutogeneratedGroupItems(item, metadata, itemContext)

        const { sidebar: entries, prev, next } = await updateAutogeneratedGroup(item, itemContext)
        if (prev) result.prev = prev
        if (next) result.next = next
        return { ...item, label, entries }
      }

      if (item.isCurrent) {
        // TODO(HiDeoo) manual prev/next
        const prevItem = getPrevNextLink('prev', index, context)
        if (prevItem) result.prev = prevItem
        const nextItem = getPrevNextLink('next', index, context)
        if (nextItem) result.next = nextItem
      }

      return {
        ...item,
        // TODO(HiDeoo)
        // label: `${item.label} (modified)`,
      }
    }),
  )

  return result
}

async function sortAutogeneratedGroupItems(
  group: SidebarGroup,
  metadata: Metadata | undefined,
  context: SidebarUpdateContext,
): Promise<SidebarGroup> {
  const orders = await getAutogeneratedGroupItemsOrder(group.entries, context)
  const collator = new Intl.Collator(getDefaultLang(context))

  orders.sort(({ order: aOrder, path: aPath }, { order: bOrder, path: bPath }) => {
    if (aOrder !== bOrder) return aOrder < bOrder ? -1 : 1
    return collator.compare(aPath, bPath) * (metadata?.sort === 'reverse-slug' ? -1 : 1)
  })

  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
  group.entries = orders.map(({ index }) => group.entries[index]!)

  return group
}

function getAutogeneratedGroupItemsOrder(
  items: SidebarItem[],
  context: SidebarUpdateContext,
): Promise<AutogeneratedGroupItemsOrder> {
  return Promise.all(
    items.map(async (item, index) => {
      if (isSidebarLink(item)) {
        return {
          index,
          order: await getEntryOrder(item.href),
          path: stripBase(stripLeadingAndTrailingSlash(item.href)),
        }
      }

      const metadata = getAutogeneratedGroupDirMetadata(createUpdateContextForGroup(item, index, context))

      return {
        index,
        order: metadata?.order ?? Number.MAX_VALUE,
        path: getAutoGeneratedGroupPath(item, context),
      }
    }),
  )
}

function getPrevNextLink(
  type: 'prev' | 'next',
  index: number,
  context: SidebarUpdateContext,
  segmentCursor = 0,
): SidebarLink | undefined {
  const segment = context.segments.at(segmentCursor - 1)
  if (!segment) return

  const { group, index: groupIndex } = segment
  let item = group.entries[index + 1 * (type === 'next' ? 1 : -1)]

  if (!item) return getPrevNextLink(type, groupIndex, context, segmentCursor - 1)

  if (isSidebarLink(item)) return item
  if (isSidebarGroup(item)) while (isSidebarGroup(item)) item = item.entries.at(type === 'next' ? 0 : -1)

  return item
}

function getAutogeneratedGroupDirMetadata(context: SidebarUpdateContext) {
  const { config, contentDir, metadata } = context
  return metadata[new URL(config.autogenerate.directory, contentDir).pathname]?.[getUpdateContextTrail(context)]
}

function isSidebarLink(item: SidebarItem | undefined): item is SidebarLink {
  return item?.type === 'link'
}

function isSidebarGroup(item: SidebarItem | undefined): item is SidebarGroup {
  return item?.type === 'group'
}

function getAutoGeneratedGroupPath(group: SidebarGroup, context: SidebarUpdateContext) {
  const trail = isAutogeneratedGroupRootSegment(context)
    ? context.config.autogenerate.directory
    : `${context.config.autogenerate.directory}/${getUpdateContextTrail(context)}`

  return `${trail}/${group.label}`
}

function isAutogeneratedGroupRootSegment(context: SidebarUpdateContext) {
  // The first segment represents the entire sidebar and the second one the autogenerated group root segment.
  return context.segments.length === 2
}

function createUpdateContextForGroup(
  group: SidebarGroup,
  index: number,
  context: SidebarUpdateContext,
): SidebarUpdateContext {
  return { ...context, segments: [...context.segments, { group, index }] }
}

function createUpdateContextRootSegment(entries: SidebarItem[]): SidebarUpdateContext['segments'][number] {
  return {
    group: { type: 'group', entries, label: String(updateContextRootSegmentLabel), collapsed: false, badge: undefined },
    index: -1,
  }
}

function getUpdateContextTrail(context: SidebarUpdateContext) {
  // The first segment represents the entire sidebar and the second one the autogenerated group root segment.
  const segments = context.segments.slice(2)
  return segments.map((segment) => segment.group.label).join('/')
}

type SidebarItem = StarlightRouteData['sidebar'][number]
type SidebarLink = Extract<SidebarItem, { type: 'link' }>
type SidebarGroup = Extract<SidebarItem, { type: 'group' }>

type PrevNextLink = StarlightRouteData['pagination']['next']

interface SidebarUpdateResult {
  sidebar: SidebarItem[]
  prev?: PrevNextLink
  next?: PrevNextLink
}

interface SidebarUpdateContext extends StarlightAutoSidebarContext {
  config: SidebarAutogeneratedGroupConfig
  segments: { group: SidebarGroup; index: number }[]
}

type AutogeneratedGroupItemsOrder = {
  index: number
  order: number
  path: string
}[]

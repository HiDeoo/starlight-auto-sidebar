import { z } from 'astro/zod'
import { getCollection, type CollectionEntry } from 'astro:content'
import context from 'virtual:starlight-auto-sidebar/context'

import { isSidebarAutogeneratedGroupConfig, isSidebarManualGroupConfig, type SidebarUserConfig } from './sidebar'
import { DefaultLocale, type Locale } from './starlight'

export const Metadatafilename = '_meta'
export const MetadataFileGlob = `${Metadatafilename}.y?(a)ml`

export const MetadataSchema = z
  .object({
    /**
     * Add a badge to the directory containing the metadata file in the sidebar when displayed in an autogenerated
     * sidebar group.
     */
    badge: z
      .union([
        z.string(),
        z.object({
          class: z.string().optional(),
          text: z.string(),
          variant: z.enum(['note', 'danger', 'success', 'caution', 'tip', 'default']).default('default'),
        }),
      ])
      .transform((value) => (typeof value === 'string' ? { text: value, variant: 'default' as const } : value))
      .optional(),
    /**
     * Cascade some options of the directory containing the metadata file to all nested directories when displayed in an
     * autogenerated sidebar group.
     */
    cascade: z.array(z.union([z.literal('collapsed'), z.literal('sort')])).optional(),
    /**
     * Define whether the directory containing the metadata file in the sidebar should be collapsed or not when
     * displayed in an autogenerated sidebar group.
     *
     * @default false
     */
    collapsed: z.boolean().default(false),
    /**
     * Limit the depth of content in the directory containing the metadata file when displayed in an autogenerated
     * sidebar group.
     *
     * @default Infinity
     */
    depth: z.number().gte(1).optional(),
    /**
     * Prevents the directory containing the metadata file from being included in an autogenerated sidebar group.
     *
     * @default false
     */
    hidden: z.boolean().default(false),
    /**
     * Set the label of the directory containing the metadata file in the sidebar when displayed in an autogenerated
     * sidebar group.
     */
    label: z.string().optional(),
    /**
     * Control the order of the directory containing the metadata file when sorting an autogenerated group.
     */
    order: z.number().optional(),
    /**
     * Control the sorting order of the content in the directory containing the metadata file.
     *
     * @default 'slug'
     */
    sort: z.enum(['slug', 'reverse-slug']).default('slug'),
  })
  .strict()

let projectMetadata: ProjectMetadata | undefined
let metadataEntries: MetadataEntry[] | undefined

export async function getProjectMetadata(sidebarConfig: SidebarUserConfig): Promise<ProjectMetadata> {
  if (projectMetadata) return projectMetadata

  let metadata = await getProjectMetadataByLocale(DefaultLocale, sidebarConfig)

  if (context.isMultilingual) {
    for (const locale in context.locales) {
      if (locale === 'root' || locale === DefaultLocale) continue
      metadata = { ...metadata, ...(await getProjectMetadataByLocale(locale, sidebarConfig)) }
    }
  }

  projectMetadata = metadata

  return metadata
}

async function getProjectMetadataByLocale(locale: Locale, sidebarConfig: SidebarUserConfig): Promise<ProjectMetadata> {
  let metadata: ProjectMetadata = {}

  for (const itemConfig of sidebarConfig) {
    if (isSidebarAutogeneratedGroupConfig(itemConfig)) {
      await collectDirectoryMetadata(metadata, locale, itemConfig.autogenerate.directory)
    } else if (isSidebarManualGroupConfig(itemConfig)) {
      metadata = { ...metadata, ...(await getProjectMetadataByLocale(locale, itemConfig.items)) }
    }
  }

  return metadata
}

async function collectDirectoryMetadata(metadata: ProjectMetadata, locale: Locale, dir: string) {
  const entries = await getMetadataEntries()

  for (const entry of entries) {
    const localizedDir = locale ? `${locale}/${dir}` : dir
    if (entry.id.startsWith(localizedDir)) {
      metadata[entry.id.replace(`/${Metadatafilename}`, '')] = entry.data
    }
  }
}

async function getMetadataEntries(): Promise<MetadataEntry[]> {
  metadataEntries ??= await getCollection('autoSidebar')
  return metadataEntries
}

export type Metadata = z.output<typeof MetadataSchema>
export type ProjectMetadata = Record<string, Metadata>

type MetadataEntry = CollectionEntry<'autoSidebar'>

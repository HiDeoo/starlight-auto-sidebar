import { z } from 'astro/zod'
import { getCollection, type CollectionEntry } from 'astro:content'

import { isSidebarAutogeneratedGroupConfig, isSidebarManualGroupConfig, type SidebarUserConfig } from './sidebar'

export const Metadatafilename = '_meta'
export const MetadataFileGlob = `${Metadatafilename}.y?(a)ml`

export const MetadataSchema = z
  .object({
    // TODO(HiDeoo) comment
    label: z.string().optional(),
    // TODO(HiDeoo) comment
    order: z.number().optional(),
    // TODO(HiDeoo) comment
    sort: z.enum(['slug', 'reverse-slug']).default('slug'),
  })
  .strict()

let metadataEntries: MetadataEntry[] | undefined

export async function getProjectMetadata(sidebarConfig: SidebarUserConfig): Promise<ProjectMetadata> {
  let metadata: ProjectMetadata = {}

  for (const itemConfig of sidebarConfig) {
    if (isSidebarAutogeneratedGroupConfig(itemConfig)) {
      await attachDirectoryMetadata(metadata, itemConfig.autogenerate.directory)
    } else if (isSidebarManualGroupConfig(itemConfig)) {
      metadata = { ...metadata, ...(await getProjectMetadata(itemConfig.items)) }
    }
  }

  return metadata
}

async function attachDirectoryMetadata(metadata: ProjectMetadata, dir: string) {
  const entries = await getMetadataEntries()

  for (const entry of entries) {
    if (entry.id.startsWith(dir)) {
      metadata[entry.id.replace(`/${Metadatafilename}`, '')] = entry.data
    }
  }
}

async function getMetadataEntries(): Promise<MetadataEntry[]> {
  if (metadataEntries) return metadataEntries
  metadataEntries = await getCollection('autoSidebar')
  return metadataEntries
}

export type Metadata = z.output<typeof MetadataSchema>
export type ProjectMetadata = Record<string, Metadata>

type MetadataEntry = CollectionEntry<'autoSidebar'>
